import sqlite3
import json
from datetime import datetime

DB_SCHEMA = """
CREATE TABLE IF NOT EXISTS feedback (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp TEXT NOT NULL,
    original TEXT NOT NULL,
    suggestions TEXT NOT NULL,
    chosen TEXT NOT NULL
);
"""


def init_db(db_path: str):
    """
    Initialize the database and create the feedback table if it does not exist.
    """
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    cursor.executescript(DB_SCHEMA)
    conn.commit()
    conn.close()


def store_feedback(original: str, suggestions: list, chosen: str, db_path: str = '../feedback.db'):
    """
    Save user feedback to the database.

    Args:
        original (str): The original text submitted for correction.
        suggestions (list): List of suggestions generated by the model.
        chosen (str): The suggestion chosen by the user.
        db_path (str): Path to the SQLite database file.
    """
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    # Ensure the feedback table exists
    cursor.executescript(DB_SCHEMA)

    timestamp = datetime.utcnow().isoformat()
    serialized_suggestions = json.dumps(suggestions, ensure_ascii=False)

    cursor.execute(
        "INSERT INTO feedback (timestamp, original, suggestions, chosen) VALUES (?, ?, ?, ?)",
        (timestamp, original, serialized_suggestions, chosen)
    )
    conn.commit()
    conn.close()


def fetch_all_feedback(db_path: str = '../feedback.db') -> list:
    """
    Retrieve all feedback entries from the database.

    Args:
        db_path (str): Path to the SQLite database file.

    Returns:
        list: A list of dictionaries, each containing a feedback record with keys:
            'id', 'timestamp', 'original', 'suggestions', 'chosen'.
    """
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    cursor.execute(
        "SELECT id, timestamp, original, suggestions, chosen FROM feedback ORDER BY id ASC"
    )
    rows = cursor.fetchall()
    conn.close()

    feedback_list = []
    for id_, ts, orig, sug_json, chosen in rows:
        feedback_list.append({
            'id': id_,
            'timestamp': ts,
            'original': orig,
            'suggestions': json.loads(sug_json),
            'chosen': chosen
        })
    return feedback_list


def clear_feedback(db_path: str = '../feedback.db'):
    """
    Remove all feedback entries from the database.

    Args:
        db_path (str): Path to the SQLite database file.
    """
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    # Ensure the feedback table exists
    cursor.executescript(DB_SCHEMA)
    # Delete all records
    cursor.execute("DELETE FROM feedback")
    conn.commit()
    conn.close()
    
if __name__=="__main__":
    print(fetch_all_feedback())